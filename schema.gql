# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""Object representing an Anime"""
type Anime {
  ageClassification: AnimeAgeClassification
  alternativeTitles: [String!]!
  endDate: DateTime
  episodes: Int
  genres: [String!]
  id: Int!
  mediaType: AnimeMediaType
  nsfw: String
  picture: String
  popularity: Int
  rank: Int
  relatedAnime: [String!]
  releasedSeason: String
  score: Float!
  source: String
  startDate: DateTime
  status: AnimeStatus!
  studios: [String!]
  synopsis: String
  title: String!
}

"""The age classification of an Anime"""
enum AnimeAgeClassification {
  G
  PG
  PG_13
  R
  RX
  R_PLUS
}

"""Object representing an anime genre query"""
type AnimeGenre {
  count: Int!
  genre: String!
}

"""The media type of an Anime"""
enum AnimeMediaType {
  MOVIE
  ONA
  OVA
  SPECIAL
  TV
}

"""The seasons in which Animes are released"""
enum AnimeSeason {
  FALL
  SPRING
  SUMMER
  WINTER
}

"""Object representing an anime source query"""
type AnimeSource {
  count: Int!
  source: String!
}

"""The status of an Anime"""
enum AnimeStatus {
  AIRING
  FINISHED
}

"""Object representing an anime studio query"""
type AnimeStudio {
  count: Int!
  studio: String!
}

"""Object representing an anime's titles"""
type AnimeTitles {
  animeId: Int!
  title: [String!]!
}

"""method for querying data"""
enum DateMethod {
  EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type Query {
  getAllAnimeTitles: [AnimeTitles!]!
  getAnimeById(id: Int!): Anime!
  getAnimeBySeason(amount: Int, hentai: Boolean = false, mediaTypes: [AnimeMediaType!], method: TopAnimeMethod = POPULARITY, season: AnimeSeason!, year: Int!): [Anime!]!
  getAnimeByTitle(hentai: Boolean = false, title: String!): [Anime!]!
  getAnimeGenres(amount: Int, hentai: Boolean = false): [AnimeGenre!]!
  getAnimeRecommendations(animeId: Int!, excludedAnimeIds: [Int!]!, k: Int!): [Recommendation!]!
  getAnimeSources(amount: Int): [AnimeSource!]!
  getAnimeStudios(amount: Int): [AnimeStudio!]!
  getGroupRecommendations(ages: [AnimeAgeClassification!], amount: Int!, animesId: [Int!]!, endDate: DateTime, endDateMethod: DateMethod, excludedAnimeIds: [Int!]!, genres: [String!], hentai: Boolean = false, mediaTypes: [AnimeMediaType!], nullEndDate: Boolean = false, sources: [String!], startDate: DateTime, startDateMethod: DateMethod, studios: [String!]): [Recommendation!]!
  getTopAnime(ages: [AnimeAgeClassification!], amount: Int = 100, endDate: DateTime, endDateMethod: DateMethod, genres: [String!], hentai: Boolean = false, mediaTypes: [AnimeMediaType!], method: TopAnimeMethod!, nullEndDate: Boolean = false, offset: Int, sources: [String!], startDate: DateTime, startDateMethod: DateMethod, status: AnimeStatus, studios: [String!], title: String): [Anime!]!
  getUser: User!
  getUserAnimeList: [UserAnimeRating!]!
  listAnimeById(ids: [Int!]!): [Anime!]!
}

"""Object representing a single Anime recommendation"""
type Recommendation {
  anime: Anime!
  rank: Int!
}

"""Criteria for getting popular Anime"""
enum TopAnimeMethod {
  POPULARITY
  SCORE
}

"""Object representing an user"""
type User {
  id: Float!
  imageURL: String
  username: String!
}

"""Object representing an user's anime rating"""
type UserAnimeRating {
  anime: Anime!
  score: Int!
  status: UserRatingStatus
}

"""Status for an user's rating"""
enum UserRatingStatus {
  COMPLETED
  DROPPED
  ON_HOLD
  PLAN_TO_WATCH
  WATCHING
}
